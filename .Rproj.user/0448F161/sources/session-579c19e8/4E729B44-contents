---
title: "Untitled"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Show code"
    embed-resources: true
    self-contained: true
    self-contained-math: true
    theme: cosmo
    df-print: paged
editor: visual
execute:
  warning: false
  message: false
editor_options: 
  chunk_output_type: console
---

```{r}
#| code-fold: false
#| echo: false

pacman::p_load(patchwork, ggraph, tidygraph, networkD3,
               tidyverse, targets, gt, plotly, virids, ggiraph)

tmp <- tar_read(path_results_branch, store = here::here("_targets_network"))

main_g <- tar_read(main_g, store = here::here("_targets_network"))
```

```{r}
#| echo: false


paths_data <- tmp %>%
  group_by(origin, destination) %>%
  pivot_longer(
    cols = c(path_in, path_out, dist_in, dist_out),
    names_to = c(".value", "direction"),
    names_pattern = "(.+)_(in|out)"
  ) %>%
  mutate(
    w_dist_inv = map_dbl(
      dist,
      ~ .x %>% pluck("weighted_distance")
    ),
    raw_dist = map_dbl(
      dist,
      ~ .x %>% pluck("raw_distance")
    ),
    node_path = map_chr(
      path,
      ~ paste(names(.x$vpath[[1]]), collapse = ",")
    ),
    edge_path = map_chr(
      path,
      ~ paste(.x$epath[[1]], collapse = ",")
    ),
    hops = str_count(node_path, ","),
    across(
      w_dist_inv:edge_path,
      ~ if_else(is.infinite(.x) | .x == "", NA, .x)
    )
    # node_path = if_else(node_path == "", NA, node_path),
    # edge_path = if_else(edge_path == "", NA, edge_path)
  ) %>%
  dplyr::select(-path, -dist, od_id = tar_group)

potential_nodes <- tmp %>%
  pull(destination) %>%
  unique()

regional_nodes <- tmp %>%
  pull(origin) %>%
  unique()


paths_data_minimal <- paths_data %>%
  group_by(od_id) %>%
  slice_min(w_dist_inv, with_ties = T, na_rm = T) %>%
  ungroup() %>%
  group_by(destination) %>%
  slice_min(w_dist_inv, with_ties = T, na_rm = T)


node_path_inter <- paths_data_minimal %>% 
  separate_longer_delim(node_path, delim = ',') %>% 
  filter(node_path != origin & node_path != destination) %>% 
  pull(node_path) %>% unique()

```

```{r}
#| code-fold: false
#| echo: false

# Define custom theme
theme_clean_html <- function(base_size = 11) {
  theme_minimal(base_size = base_size) +
    theme(
      # Background
      plot.background = element_rect(fill = "white", color = NA),
      panel.background = element_rect(fill = "white", color = NA),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "grey90", linewidth = 0.3),
      
      # Text
      plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
      plot.subtitle = element_text(color = "grey30", size = rel(1), hjust = 0, margin = margin(b = 10)),
      axis.title = element_text(size = rel(0.9), color = "grey20"),
      axis.text = element_text(size = rel(0.85), color = "grey40"),
      strip.text = element_text(face = "bold", size = rel(0.95)),
      
      # Legend
      legend.position = "bottom",
      legend.title.position = "top",
      legend.title = element_text(size = rel(0.9), face = "bold"),
      legend.text = element_text(size = rel(0.85)),
      legend.key.size = unit(0.8, "lines"),
      legend.box = "horizontal",
      legend.margin = margin(t = 10),
      
      # Facets
      strip.background = element_rect(fill = "grey95", color = NA),
      panel.spacing = unit(1.5, "lines")
    )
}

# Color palettes
cat_colors <- c(
  "A" = "#E64B35", "B" = "#4DBBD5", "C" = "#00A087", "D" = "#3C5488",
  "E" = "#F39B7F", "F" = "#8491B4", "G" = "#91D1C2", "H" = "#DC0000"
)

metric_colors <- c(
  "degree_total" = "#E64B35", "degree_in" = "#4DBBD5", 
  "degree_out" = "#00A087", #"degree_asymmetry" = "#3C5488",
  "betweenness" = "#F39B7F", "eigenvector" = "#8491B4", 
  "authority" = "#91D1C2", "hub" = "#DC0000"
)
```

```{r}
#| code-fold: false
#| echo: false

main_g %>% as_tbl_graph() -> tg 

# regional_nodes <- tg %>% 
#   activate(nodes) %>% 
#   as_tibble() %>% 
#   filter(type == "regional") %>% 
#   pull(name) %>% unique()
# 
# potential_nodes <- tg %>% 
#   activate(nodes) %>% 
#   as_tibble() %>% 
#   filter(type == "potential") %>% 
#   pull(name) %>%  unique()


tg <- tg %>% 
  activate(nodes) %>%
  mutate(
    type = case_when(
      name %in% regional_nodes ~ "regional",
      name %in% potential_nodes ~ "potential",
      name %in% node_path_inter & name %in% potential_nodes ~ "intermediate potential",
      name %in% node_path_inter & !(name %in% potential_nodes) ~ "intermediate",
      T ~ "outsider"
    )
  ) %>% 
  mutate(
    category = str_sub(name, end = 1),
    # technology = name,
    # category = category,  # uncomment if you have this attribute
    
    # Degree centralities
    degree_total = centrality_degree(mode = "total"), #(weights = weight),
    degree_in = centrality_degree(mode = "in"), #(mode = "in", weights = weight),
    degree_out = centrality_degree(mode = "out"), #(mode = "out", weights = weight),
    # 
    # Degree asymmetry (custom)
    # degree_asymmetry = degree_in / (degree_out + 0.001),  # +0.001 to avoid division by zero
    
    # Betweenness (weighted)
    betweenness = centrality_betweenness(directed = TRUE),
    
    # Closeness (weighted - inverts weights by default)
    # closeness_in = centrality_closeness(mode = "in"), # weights = weight),
    # closeness_out = centrality_closeness(mode = "out"), #, weights = weight),
    
    # Constraint (Burt's structural holes)
    burt_constraint = node_constraint(weights = weight),
    
    # Eigenvector centrality (weighted)
    eigenvector = centrality_eigen(weights = weight, directed = TRUE),
    
    # Authority and Hub scores (weighted)
    authority = centrality_authority(weights = weight),
    hub = centrality_hub(weights = weight)
  ) %>% 
  activate(edges) %>% 
  mutate(
    e_betweeness = centrality_edge_betweenness(directed = T)
  )


tg <- tg %>%
  activate(edges) %>%
  # as_tibble() %>%
  mutate(
    from_name = tg %>% activate(nodes) %>% pull(name) %>% .[from],
    to_name = tg %>% activate(nodes) %>% pull(name) %>% .[to],
    from_cat = tg %>% activate(nodes) %>% pull(category) %>% .[from],
    to_cat = tg %>% activate(nodes) %>% pull(category) %>% .[to]
  )


centrality_results <- tg %>%
  activate(nodes) %>%
  as_tibble()


```

## The network of technologies as is

```{r}
#| column: page
#| code-fold: true
#| fig-width: 16
#| fig-height: 11
#| fig-dpi: 150
#| out-width: "100%"


tg %>% 
  ggraph(layout = "fr") +
  geom_edge_arc(
    aes(alpha = e_betweeness),
    color = "grey70",
    strength = 0.15,
    arrow = arrow(length = unit(1.5, "mm"), type = "closed"),
    end_cap = circle(3, "mm"),
    show.legend = FALSE,
    linewidth = 0.3
  ) +
  geom_node_point(
    aes(color = category, size = degree_total, alpha = eigenvector),
    shape = 16
  ) +
  scale_color_manual(values = cat_colors, name = "IPC Category") +
  scale_size_continuous(
    name = "Total Degree",
    range = c(1, 12),
    guide = guide_legend(nrow = 2, order = 2)
  ) +
  scale_alpha_continuous(
    name = "Eigenvector Centrality",
    range = c(0.5, 1),
    guide = guide_legend(nrow = 2, order = 3)
  ) +
  geom_node_text(aes(label = ifelse(eigenvector >= 0.115, name, "")),
    repel = TRUE, size = 3
  ) +
  labs(
    title = "Technology Network(based on 2018 patent data)",
    subtitle = "Node size = degree, transparency = eigenvector centrality"
  ) +
  theme_graph(base_size = 11) +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(color = "grey40", size = 10, hjust = 0.5, margin = margin(b = 15)),
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.title = element_text(size = 9, face = "bold"),
    legend.text = element_text(size = 8),
    legend.margin = margin(t = 15)
  ) +
  guides(
    color = guide_legend(nrow = 2, order = 1, override.aes = list(size = 4, alpha = 1))
  )
```

## Network metrics

```{r}
#| output: asis
#| code-fold: true
#| column: page
#| fig-width: 10
#| fig-height: 7
#| fig-dpi: 150
#| out-width: "100%"

metrics_list <- c("degree_total", "burt_constraint",
                  "betweenness", "eigenvector", "authority", "hub")

centrality_ranked <- centrality_results %>%
  select(name, category, all_of(metrics_list)) %>%
  mutate(across(all_of(metrics_list), 
                ~dense_rank(desc(.)), 
                .names = "rank_{.col}"))

cat("::: {.panel-tabset}\n\n")

for(metric in metrics_list) {
  
  cat(sprintf("### %s\n\n", tools::toTitleCase(gsub("_", " ", metric))))
  
  # Stats
  stats <- centrality_results %>%
    summarise(across(!!sym(metric), 
                     list(mean = mean, median = median, sd = sd, min = min, max = max),
                     .names = "{.fn}"))
  
  cat(sprintf("**μ=%.3f | Q2=%.3f | σ=%.3f | [%.3f–%.3f]**\n\n",
              stats$mean, stats$median, stats$sd, stats$min, stats$max))
  
   # Start two-column layout
  cat("::: {layout-ncol=2}\n\n")
  
  # Plot
  p <- ggplot(centrality_results, aes(x = .data[[metric]], fill = category)) +
    geom_density(alpha = 0.3) +
    scale_fill_manual(values = cat_colors) +
    labs(x = metric, y = "Density", fill = "Category") +
    theme_clean_html()
  
  print(p)
  cat("\n\n")
  
  # Table
  rank_col <- paste0("rank_", metric)

centrality_ranked %>%
  arrange(.data[[rank_col]]) %>%
  slice_head(n = 20) %>%
  mutate(
    across(
      all_of(metrics_list),
      ~paste0(round(., 3), "\n(", get(paste0("rank_", cur_column())), ")"),
      .names = "display_{.col}"
    )
  ) %>%
  select(Tech = name, Cat = category, starts_with("display_")) %>%
  rename_with(~gsub("display_", "", .), starts_with("display_")) %>%
  gt(rowname_col = "Tech") %>%
  # Clear column labels with descriptions
  cols_label(
    Tech = "Technology",
    Cat = "IPC",
    degree_total = md("**Degree**<br><span style='font-size:9px;color:#666;'>Total connections</span>"),
    burt_constraint = md("**Constraint**<br><span style='font-size:9px;color:#666;'>Structural holes</span>"),
    betweenness = md("**Betweenness**<br><span style='font-size:9px;color:#666;'>Bridge position</span>"),
    eigenvector = md("**Eigenvector**<br><span style='font-size:9px;color:#666;'>Connected to important</span>"),
    authority = md("**Authority**<br><span style='font-size:9px;color:#666;'>Cited by important</span>"),
    hub = md("**Hub**<br><span style='font-size:9px;color:#666;'>Cites important</span>")
  ) %>%
  # Highlight focal metric
  tab_style(
    style = list(
      cell_fill(color = "#FFF9C4"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(columns = !!sym(metric))
  ) %>%
  # Style column headers
  tab_style(
    style = list(
      cell_fill(color = "#f0f0f0"),
      cell_text(weight = "bold", align = "center")
    ),
    locations = cells_column_labels()
  ) %>%
  # Column widths
  cols_width(
    Tech ~ px(50),
    Cat ~ px(35),
    everything() ~ px(80)
  ) %>%
  # Alignment
  cols_align(align = "center", columns = -c(Tech, Cat)) %>%
  cols_align(align = "left", columns = Tech) %>%
  # Table options
  tab_options(
    table.font.size = 10,
    heading.align = "left",
    column_labels.font.size = 11,
    column_labels.padding = px(10),
    data_row.padding = px(6)
  ) %>%
  # Add footnote
  tab_footnote(
    footnote = "Values shown as: metric_value (rank)",
    locations = cells_column_labels(columns = degree_total)
  ) %>%
  print()
    
  cat("\n\n")
  # End two-column layout
  cat(":::\n\n")
}

cat(":::\n\n")
```

::::: column-page
## Embededness

:::: panel-tabset
### Categories

```{r}
#| code-fold: true


# Step 1: Extract nodes with categories
nodes_with_cat <- tg %>%
  activate(nodes) %>%
  as_tibble()

# Step 2: Match by index
edges_with_cat <- tg %>%
  activate(edges) %>%
  as_tibble() %>%
  mutate(
    from_name = tg %>% activate(nodes) %>% pull(name) %>% .[from],
    to_name = tg %>% activate(nodes) %>% pull(name) %>% .[to],
    from_cat = tg %>% activate(nodes) %>% pull(category) %>% .[from],
    to_cat = tg %>% activate(nodes) %>% pull(category) %>% .[to]
  )

# Step 3: Aggregate to category level
category_edges <- edges_with_cat %>%
  group_by(from_cat, to_cat) %>%
  summarise(
    n_edges = n(),                          # Count of edges
    mean_weight = mean(weight, na.rm = TRUE),   # Average weight
    .groups = "drop"
  ) %>% 
  mutate(
    from_cat_color = from_cat,
    self_loop = from_cat == to_cat
  )

# Step 4: Create category-level nodes
category_nodes <- tg %>%
  activate(nodes) %>%
  as_tibble() %>%
  group_by(category) %>%
  summarise(
    n_techs = n(),
    avg_degree = mean(degree_total),
    avg_betweenness = mean(betweenness, na.rm = TRUE),
    avg_eigenvector = mean(eigenvector, na.rm = TRUE),
    avg_authority = mean(authority, na.rm = TRUE),
    avg_hub = mean(hub, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rename(name = category)



# Calculate embeddedness for each category
embeddedness_stats <- edges_with_cat %>% 
  # select(from_cat, to_cat) %>% 
  group_by(from_cat, to_cat) %>% 
  summarise(oc = n(),  avg_weight = round(mean(weight, na.rm = TRUE), 1)) %>% 
  pivot_longer(c(oc, avg_weight)) %>% 
  pivot_wider(names_from = "to_cat", values_from = "value") %>% 
  ungroup() %>% 
  mutate(
    Total = rowSums(across(A:H))
  ) %>%
  mutate(
    across(
      A:H,
      ~paste0(.x, " (", round(100 * .x / Total, 1), "%)")
    ),
    name = if_else(name == "oc", "Edges", "Weight"),
  ) %>% 
  gt(groupname_col = "name") %>%
  tab_header(
    title = md("**Technology Category Embeddedness Matrix**"),
    subtitle = "Number of edges (% of total) Count (% of row) and Average edge weight flowing from source to target category"
  ) %>%
  cols_label(
    from_cat = md("**From**"),
    A = md("**A**"), B = md("**B**"), C = md("**C**"), D = md("**D**"),
    E = md("**E**"), F = md("**F**"), G = md("**G**"), H = md("**H**"),
    Total = md("**Total**")
  ) %>%
  
  # Highlight diagonal (within-category)
  tab_style(
    style = list(
      cell_fill(color = "#FFF9C4"),
      cell_text(weight = "bold")
    ),
    locations = list(
      cells_body(columns = A, rows = from_cat == "A"),
      cells_body(columns = B, rows = from_cat == "B"),
      cells_body(columns = C, rows = from_cat == "C"),
      cells_body(columns = D, rows = from_cat == "D"),
      cells_body(columns = E, rows = from_cat == "E"),
      cells_body(columns = F, rows = from_cat == "F"),
      cells_body(columns = G, rows = from_cat == "G"),
      cells_body(columns = H, rows = from_cat == "H")
    )
  ) %>%
  # Style headers
  tab_style(
    style = cell_fill(color = "#E8E8E8"),
    locations = cells_column_labels()
  ) %>%
  # Column widths
  cols_width(
    from_cat ~ px(60),
    A:H ~ px(85),
    Total ~ px(70)
  ) %>%
  cols_align(align = "center", columns = A:Total) %>%
  cols_align(align = "center", columns = from_cat) %>%
  # Table options
  tab_options(
    table.font.size = 10,
    heading.align = "left",
    column_labels.font.weight = "bold",
    data_row.padding = px(8)
  ) %>%
  tab_source_note(
    md("*Diagonal values (highlighted) show within-category connections (embeddedness)*")
  )

embeddedness_stats
  
```

```{r}
#| code-fold: true

category_nodes %>% 
  gt() %>%
  tab_header(
    title = md("**Technology Category Summary Statistics**"),
    subtitle = "Average metrics and embeddedness by category"
  ) %>%
  cols_label(
    name = md("**Category**"),
    n_techs = md("**# Techs**"),
    avg_degree = md("**Avg<br>Degree**"),
    avg_betweenness = md("**Avg<br>Betweenness**"),
    avg_eigenvector = md("**Avg<br>Eigenvector**"),
    avg_authority = md("**Avg<br>Authority**"),
    avg_hub = md("**Avg<br>Hub**")
  ) %>%
  fmt_number(
    columns = c(avg_degree, avg_betweenness, avg_eigenvector, 
                avg_authority, avg_hub),
    decimals = 2
  ) %>%
  tab_style(
    style = cell_fill(color = "#E8E8E8"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = name)
  ) %>%
  cols_align(align = "center", columns = -name) %>%
  cols_align(align = "left", columns = name) %>%
  tab_options(
    table.font.size = 10,
    heading.align = "left",
    column_labels.font.size = 9,
    data_row.padding = px(6)
  ) 
```

### Technologies

```{r}
#| echo: false


tech_emb <- tg %>% 
  activate(edges) %>% 
  as_tibble() %>% 
  group_by(from_name, to_cat) %>% 
  mutate(
    oc_out = n()
  ) %>% 
  ungroup() %>% 
  group_by(to_name, from_cat) %>% 
  mutate(
    oc_in = n()
  ) %>% 
  ungroup() %>% 
  group_by(to_name) %>%
  mutate(
    total_in = sum(oc_in),
    pct_in = oc_in / total_in * 100
  ) %>%
  ungroup() %>%
  group_by(from_name) %>%
  mutate(
    total_out = sum(oc_out),
    pct_out = oc_out / total_out * 100
  ) %>%
  ungroup() %>% 
  mutate(
    # Order technologies by category first, then by connections
    to_name =  forcats::fct_reorder2(
      to_name, 
      as.numeric(factor(to_cat, levels = LETTERS[1:8])),  # Category order
      -pct_in  # Then by connections within category
    ),
    from_name =  forcats::fct_reorder2(
      from_name, 
      as.numeric(factor(from_cat, levels = LETTERS[1:8])),  # Category order
      -pct_out  # Then by connections within category
    ),
     hover_text_in = paste0(
      "<b>", to_name, "</b><br>",
      "From: ", from_cat, "<br>",
      "% Incoming: ", round(pct_in, 1), "%<br>",
      "Count: ", oc_in
    ),
    hover_text_out = paste0(
      "<b>", from_name, "</b><br>",
      "From: ", to_cat, "<br>",
      "% Incoming: ", round(pct_out, 1), "%<br>",
      "Count: ", oc_out
    )
  )

  
```

::: panel-tabset
#### Incoming edges

```{r}
#| code-fold: true

# Incoming edges heatmap
p_in <- tech_emb %>%
  ggplot(aes(x = from_cat, y = to_name)) +
  geom_tile_interactive(
    aes(
      fill = pct_in,
      tooltip = hover_text_in,
      data_id = to_name
    ),
    color = "white",
    linewidth = 0.1
  ) +
  scale_fill_viridis_c(
    option = "plasma",
    name = "% Incoming",
    labels = scales::percent_format(scale = 1)
  ) +
  labs(
    title = "Incoming Connections",
    x = "Source Category",
    y = NULL
  ) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.ticks.y = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold", size = 12),
    legend.position = "bottom"
  )

# Render interactive
girafe(
  ggobj = p_in,
  width_svg = 6,
  height_svg = 20,
  options = list(
    opts_hover(css = "fill:orange;stroke:black;stroke-width:2;"),
    opts_tooltip(
      css = "background-color:white;color:black;padding:10px;border-radius:5px;box-shadow:0 0 10px rgba(0,0,0,0.5);",
      opacity = 0.95
    ),
    opts_sizing(rescale = TRUE)
  )
)
```

#### Outgoing edges

```{r}

#| code-fold: true

# Outgoing edges heatmap
p_out <- tech_emb %>%
  ggplot(aes(x = to_cat, y = from_name)) +
  geom_tile_interactive(
    aes(
      fill = pct_out,
      tooltip = hover_text_out,
      data_id = from_name
    ),
    color = "white",
    linewidth = 0.1
  ) +
  scale_fill_viridis_c(
    option = "plasma",
    name = "% Outgoing",
    labels = scales::percent_format(scale = 1)
  ) +
  labs(
    title = "Outgoing Connections",
    x = "Destination Category",
    y = NULL
  ) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.ticks.y = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold", size = 12),
    legend.position = "bottom"
  )

# Render interactive
girafe(
  ggobj = p_out,
  width_svg = 6,
  height_svg = 20,
  options = list(
    opts_hover(css = "fill:orange;stroke:black;stroke-width:2;"),
    opts_tooltip(
      css = "background-color:white;color:black;padding:10px;border-radius:5px;box-shadow:0 0 10px rgba(0,0,0,0.5);",
      opacity = 0.95
    ),
    opts_sizing(rescale = TRUE)
  )
)

```
:::
::::
:::::

## The case of Budapest

```{r}
#| column: page
#| code-fold: true
#| fig-width: 16
#| fig-height: 11
#| fig-dpi: 150
#| out-width: "100%"


  

tg %>% 
  ggraph(layout = "fr") +
  geom_edge_arc(
    alpha = 0.2,
    color = "grey70",
    strength = 0.15,
    arrow = arrow(length = unit(1.5, "mm"), type = "closed"),
    end_cap = circle(3, "mm"),
    linewidth = 0.3
  ) +
  # Glow for regional/potential
  geom_node_point(
    aes(
      # filter = type %in% c("regional", "potential", "intermediate"),
      color = type,
      size = type
    ),
    alpha = 0.2
  ) +
  # Main nodes
  geom_node_point(
    aes(
      color = type,
      size = type,
      alpha = type
    )
  ) +
  # Labels
  geom_node_text(
    aes(
      filter = type %in% c("regional", "potential", "intermediate"),
      label = name, 
      colour = type
    ),
    size = 3,
    repel = TRUE,
    fontface = "bold"
  ) +
  scale_color_manual(
    values = c(
      "regional" = "#E64B35",
      "potential" = "#4DBBD5",
      "intermediate" = "grey30",
      "outsider" = "grey80"
    ),
    name = "Type"
  ) +
  scale_size_manual(
    values = c("regional" = 8, "potential" = 8, "intermediate" = 5, "outsider" = 2),
    guide = "none"
  ) +
  scale_alpha_manual(
    values = c("regional" = 0.8, "potential" = 0.7, "intermediate" = 0.4, "outsider" = 0.1),
    guide = "none"
  ) +
  labs(title = "Budapest Technology Network") +
  theme_graph(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    legend.position = "bottom",
    legend.title.position = "top",
    plot.background = element_rect(fill = "white", color = NA)
  )
```

```{r}
#| echo: false
#| code-fold: false
edges_data_ <- tg %>% 
  activate(edges) %>% 
  as_tibble()

emb_tech_out <- edges_data_ %>% 
  group_by(from_name) %>%
  mutate(total_edges = n()) %>%  # Total for each technology
  group_by(name = from_name, cat = to_cat) %>% 
  summarise(
    dir = "to",
    avg_weight = mean(weight),
    oc = n(),
    pct = oc / first(total_edges) * 100
  ) %>% 
  ungroup() 

emb_tech_in <- edges_data_ %>%
  group_by(to_name) %>%
  mutate(total_edges = n()) %>%  # Total for each technology
  group_by(name = to_name, cat = from_cat) %>% 
  summarise(
    dir = "from",
    avg_weight = mean(weight),
    oc = n(),
    pct = oc / first(total_edges) * 100
  ) %>% 
  ungroup() 

tech_emb_all <- bind_rows(
  emb_tech_in, emb_tech_out
) %>% 
  select(name, dir, cat, everything())

```

### Overview

```{r}
#| code-fold: true


tech_nodes <- tg %>% 
  activate(nodes) %>% 
  as_tibble() %>% 
  filter(type %in% c("regional", "potential")) %>% 
  group_by(type) %>%
  summarise(
    n_techs = n(),
    avg_degree_all = mean(degree_total),
    avg_degree_in = mean(degree_in),
    avg_degree_out = mean(degree_out),
    avg_betweenness = mean(betweenness, na.rm = TRUE),
    avg_eigenvector = mean(eigenvector, na.rm = TRUE),
    avg_authority = mean(authority, na.rm = TRUE),
    avg_hub = mean(hub, na.rm = TRUE),
    .groups = "drop"
  ) 


tech_nodes %>% 
  gt() %>%
  tab_header(
    title = md("**Technology Network Summary Statistics**"),
    subtitle = "Average metrics"
  ) %>%
  cols_label(
    n_techs = md("**# Techs**"),
    avg_degree_all = md("**Avg<br>Degree**"),
    avg_degree_in = md("**Avg<br>Degree-in**"),
    avg_degree_out = md("**Avg<br>Degree-out**"),
    avg_betweenness = md("**Avg<br>Betweenness**"),
    avg_eigenvector = md("**Avg<br>Eigenvector**"),
    avg_authority = md("**Avg<br>Authority**"),
    avg_hub = md("**Avg<br>Hub**")
  ) %>%
  fmt_number(
    decimals = 1
  ) %>%
  tab_style(
    style = cell_fill(color = "#E8E8E8"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = type)
  ) %>%
  cols_align(align = "center", columns = -type) %>%
  cols_align(align = "left", columns = type) %>%
  tab_options(
    table.font.size = 10,
    heading.align = "left",
    column_labels.font.size = 9,
    data_row.padding = px(6)
  ) 
```

```{r}
#| code-fold: true
#| fig-width: 7
#| fig-height: 4
#| fig-dpi: 150
#| out-width: "100%"

tg %>% 
  activate(nodes) %>% 
  as_tibble() %>% 
  filter(type %in% c("regional", "potential")) %>% 
  pivot_longer(degree_total:hub, names_to = "metric") %>% 
  ggplot() +
  geom_density(
    aes(x = value, color = type)
  )+
  facet_wrap(~ metric, scales = "free") +
  labs(title = "Distribution of the Network metrics of Regional and Potential nodes") +
  theme_minimal()
```

::: panel-tabset
### Regional nodes

```{r}
#| code-fold: true
#| output: true
#| column: page

tech_emb_all %>% 
  filter(name %in% regional_nodes) %>% 
  mutate(
    across(everything(), ~ replace_na(.x, 0)),
    links = paste0(oc, " (", round(pct, 1), "%)"),
    dir = case_when(
      dir == "to" ~ "Outgoing (To)",
      dir == "from" ~ "Incoming (From)",
      TRUE ~ dir
    )
  ) %>% 
  select(-oc, -pct) %>% 
  pivot_wider(
    names_from = cat, 
    values_from = c(avg_weight, links), 
    names_sep = "|", 
    values_fill = list(avg_weight = 0, links = "0 (0.0%)")
  ) %>%
  gt(rowname_col = "name", groupname_col = "dir") %>% 
  tab_spanner_delim(delim = "|") %>% 
  fmt_number(decimals = 1) %>% 
  tab_header(
    title = md("**Regional Technologies: Network Connections**"),
    subtitle = "Edge counts (%) and average weights by category"
  ) %>% 
   tab_options(
    table.font.size = 9,
    heading.title.font.size = 12,
    heading.subtitle.font.size = 9,
    data_row.padding = px(4)
  )

```

### Potential nodes

```{r}
#| column: page
#| code-fold: true
#| output: true

tech_emb_all %>% 
  filter(name %in% potential_nodes) %>% 
  mutate(
    across(everything(), ~ replace_na(.x, 0)),
    links = paste0(oc, " (", round(pct, 1), "%)"),
    dir = case_when(
      dir == "to" ~ "Outgoing (To)",
      dir == "from" ~ "Incoming (From)",
      TRUE ~ dir
    )
  ) %>% 
  select(-oc, -pct) %>% 
  pivot_wider(
    names_from = cat, 
    values_from = c(avg_weight, links), 
    names_sep = "|", 
    values_fill = list(avg_weight = 0, links = "0 (0.0%)")
  ) %>%
  gt(rowname_col = "name", groupname_col = "dir") %>% 
  tab_spanner_delim(delim = "|") %>% 
  fmt_number(decimals = 1) %>% 
  tab_header(
    title = md("**Potential Technologies: Network Connections**"),
    subtitle = "Edge counts (%) and average weights by category"
  ) %>% 
   tab_options(
    table.font.size = 9,
    heading.title.font.size = 12,
    heading.subtitle.font.size = 9,
    data_row.padding = px(4)
  )
```
:::

### The optimal path for diversification

```{r}
#| code-fold: true
#| output: true

## this is wrong because it gives us also the 
## origin and destination nodes. 

# node_path <- paths_data_minimal %>% 
#   separate_longer_delim(node_path, delim = ',') %>% 
#   pull(node_path) %>% unique()
# 
# 
# node_path_inter <- node_path[!(node_path %in% regional_nodes) & !(node_path %in% potential_nodes)]

tech_nodes_asis <- tg %>% 
  activate(nodes) %>% 
  as_tibble() 

tech_chars <- left_join(tech_nodes_asis, tech_emb_all)
  # filter(name %in% node_path_inter) 

tech_chars %>%
  filter(name %in% node_path_inter) %>% 
  pivot_longer(degree_total:hub, names_to = 'metric') %>%
  ggplot() +
  geom_density(
    aes(x = value)
  ) +
  facet_wrap(~ metric, scales = 'free') +
  labs(title = "Network characteristics of the optimal paths") +
  theme_clean_html()

  
# paths_data_minimal %>% 
#   ungroup() %>% 
#   separate_longer_delim(node_path, ",") %>% 
#   filter(node_path %in% node_path_inter) %>% 
#   # group_by(od_id) %>% 
#   count(node_path) %>% 
#   ggplot() +
#   geom_histogram(aes(x = n))

# 
# 
# tech_chars %>% 
#   pivot_longer(degree_total:hub, names_to = 'metric') %>% 
#   ggplot() +
#   geom_point(
#     aes(x = pct, y = cat, colour = category)
#   ) +
#   geom_violin(
#     aes(x = pct, y = cat), alpha = 0.1
#   ) +
#   scale_color_manual(values = cat_colors) +
#   facet_wrap(~ dir, scales = 'free') +
#   theme_clean_html()
# 
# tech_chars %>% 
#   pivot_longer(degree_total:hub, names_to = 'metric') %>% 
#   ggplot() +
#   ggridges::geom_density_ridges(
#     aes(x = pct, y= cat, fill = dir, color = dir), alpha = 0.4
#   )


```

```{r}
#| code-fold: true
#| output: true

p_path <- tech_chars %>% 
  mutate(
    dir2 = if_else(dir == "to", "Outgoing", "Incoming", missing = NA),
    hover_text = paste0(
      "<b>", name, "</b><br>",
      dir, ' ', cat, "<br>",
      "%", dir2, ": ", round(pct, 1), "%<br>",
      "Count: ", oc
    )
  ) %>% 
  ggplot(aes(x = cat, y = name)) +
  geom_tile_interactive(
    aes(
      fill = pct,
      tooltip = hover_text,
      data_id = name
    ),
    color = "white",
    linewidth = 0.1
  ) +
  scale_fill_viridis_c(
    option = "plasma",
    name = "% links",
    labels = scales::percent_format(scale = 1)
  ) +
  facet_wrap_interactive(~ dir) +
  labs(
    title = "Connections",
    x = "Direction Category",
    y = NULL
  ) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.ticks.y = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold", size = 12),
    legend.position = "bottom",
    legend.title.position = 'top'
  )

# Render interactive
girafe(
  ggobj = p_path,
  width_svg = 6,
  height_svg = 20,
  options = list(
    opts_hover(css = "fill:orange;stroke:black;stroke-width:2;"),
    opts_tooltip(
      css = "background-color:white;color:black;padding:10px;border-radius:5px;box-shadow:0 0 10px rgba(0,0,0,0.5);",
      opacity = 0.95
    ),
    opts_sizing(rescale = TRUE)
  )
)

```

## A simple regression

```{r}
reg_data <- tech_chars %>%
  mutate(
    entry = as.integer(type == "potential")
  )

mo <- lm(
  data = reg_data,
  entry ~ degree_total + betweenness + burt_constraint + eigenvector + avg_weight + pct + cat:dir
)

summary(mo)

paths_data_minimal %>%  filter(hops >=2)
```
